name: Build Termux Bootstraps

# O workflow ser√° acionado manualmente atrav√©s da interface do GitHub.
# Isso d√° controle total sobre quando iniciar o build, que √© intensivo e demorado.
on:
  workflow_dispatch:
    # Opcional: definir entradas para personalizar o build, como a arquitetura.
    inputs:
      architectures:
        description: 'Arquiteturas para build (separadas por v√≠rgula, ex: aarch64,arm,i686,x86_64)'
        required: true
        default: 'aarch64,arm,i686,x86_64'
      force_rebuild:
        description: 'For√ßar rebuild limpo? (usa a flag -f)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  # O nome do pacote da sua aplica√ß√£o. Esta √© a vari√°vel mais cr√≠tica.
  # Ela define o $PREFIX interno (ex: /data/data/com.tclabs.codestudio/files/usr).
  # O script build-bootstraps.sh deve ler este valor de properties.sh.
  TERMUX_APP_PACKAGE: "com.tclabs.codestudio"

jobs:
  build-bootstraps:
    name: Build Bootstrap Zips
    # Executar em um runner Linux. O padr√£o 'ubuntu-latest' √© adequado,
    # pois o script usa Docker internamente para criar o ambiente de compila√ß√£o.
    runs-on: ubuntu-latest

    steps:
      # Passo 1: Checkout do reposit√≥rio
      # √â ESSENCIAL que voc√™ tenha feito um fork do reposit√≥rio termux-packages
      # e j√° tenha modificado o arquivo 'properties.sh' nele para definir
      # TERMUX_APP_PACKAGE="com.tclabs.codestudio".
      - name: Checkout do reposit√≥rio termux-packages
        uses: actions/checkout@v4
        with:
          # Verifica o reposit√≥rio inteiro, incluindo hist√≥rico.
          # O script precisa dos submodules e da estrutura completa.
          fetch-depth: 0

      # Passo 2: Verificar se o script build-bootstraps.sh existe
      # Esta √© uma verifica√ß√£o de seguran√ßa cr√≠tica. O script DEVE estar presente
      # em scripts/build-bootstraps.sh. Segundo o coment√°rio, ele est√° oficialmente
      # no reposit√≥rio termux-packages.
      - name: Verificar script de build
        id: check_script
        run: |
          if [ -f "./scripts/build-bootstraps.sh" ]; then
            echo "‚úÖ Script build-bootstraps.sh encontrado."
            echo "script_exists=true" >> $GITHUB_OUTPUT
            # Exibir ajuda do script para refer√™ncia
            echo "--- Conte√∫do da ajuda do script ---"
            head -50 ./scripts/build-bootstraps.sh | grep -A 30 "show_help()" || echo "N√£o foi poss√≠vel exibir ajuda."
          else
            echo "‚ùå ERRO CR√çTICO: scripts/build-bootstraps.sh n√£o encontrado."
            echo "script_exists=false" >> $GITHUB_OUTPUT
            # Sugere a a√ß√£o correta baseada no coment√°rio.
            echo "O script deve estar no reposit√≥rio termux-packages."
            echo "Consulte: https://github.com/termux/termux-packages/wiki/For-maintainers#build-bootstrap-archives"
            exit 1
          fi

      # Passo 3: Verificar se o pacote foi personalizado
      # O build s√≥ funcionar√° se TERMUX_APP_PACKAGE foi alterado de 'com.termux'.
      # Esta verifica√ß√£o impede builds in√∫teis com o prefixo errado.
      - name: Verificar personaliza√ß√£o do pacote
        id: check_package
        run: |
          # Tenta encontrar a defini√ß√£o em properties.sh. A sintaxe pode variar.
          if grep -q "TERMUX_APP_PACKAGE" ./properties.sh; then
            CURRENT_PACKAGE=$(grep "TERMUX_APP_PACKAGE" ./properties.sh | head -1 | cut -d'=' -f2 | tr -d ' "\047')
            echo "üì¶ TERMUX_APP_PACKAGE atual definido como: '$CURRENT_PACKAGE'"
            if [ "$CURRENT_PACKAGE" = "${{ env.TERMUX_APP_PACKAGE }}" ]; then
              echo "‚úÖ O pacote est√° configurado corretamente para seu app."
              echo "package_correct=true" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è  AVISO: TERMUX_APP_PACKAGE em properties.sh ($CURRENT_PACKAGE) n√£o corresponde ao desejado (${{ env.TERMUX_APP_PACKAGE }})."
              echo "O build usar√° o valor do arquivo, n√£o a vari√°vel de ambiente."
              echo "Isso pode resultar em bootstraps com o prefixo errado."
              echo "package_correct=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ùå ERRO: TERMUX_APP_PACKAGE n√£o est√° definido em properties.sh."
            echo "O build-bootstraps.sh depende desta vari√°vel."
            echo "Adicione a linha: TERMUX_APP_PACKAGE=\"${{ env.TERMUX_APP_PACKAGE }}\""
            exit 1
          fi

      # Passo 4: Configurar o ambiente Docker e depend√™ncias
      # O script 'run-docker.sh' lida com a cria√ß√£o do container. O GitHub Actions
      # precisa de permiss√£o para executar Docker.
      - name: Configurar Docker e permiss√µes
        run: |
          # Garantir que os scripts sejam execut√°veis
          chmod +x ./scripts/run-docker.sh ./scripts/build-bootstraps.sh 2>/dev/null || true
          # O runner do GitHub j√° tem Docker instalado. Esta √© uma verifica√ß√£o.
          docker --version
          echo "‚úÖ Ambiente Docker verificado."

      # Passo 5: Executar o build dos bootstraps
      # Este √© o n√∫cleo do processo. A chamada espelha exatamente as instru√ß√µes:
      # ./scripts/run-docker.sh ./scripts/build-bootstraps.sh [op√ß√µes]
      # A redire√ß√£o de log (&> build.log) √© feita de forma diferente no Actions.
      - name: Executar build dentro do Docker
        id: run_build
        # Continue mesmo se houver erros n√£o-cr√≠ticos (como falha em um pacote).
        # O script pode ser interrompido por erros de URL, mas √†s vezes um re-run funciona.
        continue-on-error: true
        run: |
          # Construir a linha de comando com base nos inputs.
          CMD="./scripts/run-docker.sh ./scripts/build-bootstraps.sh"

          # Adicionar arquiteturas. O valor padr√£o do input √© usado se n√£o especificado.
          CMD="$CMD --architectures '${{ github.event.inputs.architectures }}'"

          # Adicionar flag -f (force) se solicitado. ISSO √â IMPORTANTE.
          # Conforme o coment√°rio, usar -f limpa builds anteriores e garante
          # que tudo seja compilado com o novo prefixo.
          if [ "${{ github.event.inputs.force_rebuild }}" = "true" ]; then
            CMD="$CMD -f"
            echo "üî® Modo 'force' ativado. Build limpo ser√° executado."
          fi

          # Adicionar redirecionamento de logs para um arquivo e tamb√©m para o console.
          # O pipe 'tee' permite monitorar em tempo real.
          FULL_CMD="$CMD 2>&1 | tee -a build.log"
          echo "Comando a ser executado: $CMD"
          echo "Iniciando build... Este processo pode levar V√ÅRIAS HORAS."

          # Executar o comando. O tempo limite padr√£o do GitHub √© 6h, o que pode
          # n√£o ser suficiente. Definimos um timeout maior explicitamente.
          timeout 8h bash -c "$FULL_CMD" || BUILD_EXIT_CODE=$?

          # Analisar o resultado da execu√ß√£o.
          if [ -z "$BUILD_EXIT_CODE" ]; then
            # timeout n√£o foi atingido, o comando terminou por si s√≥.
            echo "‚úÖ Build conclu√≠do (comando encerrado)."
            echo "build_status=success" >> $GITHUB_OUTPUT
          elif [ "$BUILD_EXIT_CODE" -eq 124 ]; then
            # C√≥digo 124 significa que o timeout (8h) foi atingido.
            echo "‚ö†Ô∏è  AVISO: Build interrompido por timeout (8 horas)."
            echo "O processo pode n√£o ter terminado completamente."
            echo "Considere aumentar o tempo ou build por arquiteturas separadas."
            echo "build_status=timeout" >> $GITHUB_OUTPUT
          else
            # Outro erro ocorreu durante o build.
            echo "‚ö†Ô∏è  Build encontrou um erro (C√≥digo de sa√≠da: $BUILD_EXIT_CODE)."
            echo "Isso pode ser esperado para alguns pacotes problem√°ticos (ex: bzip2, curl)."
            echo "Verifique os logs abaixo e o arquivo 'build.log' completo."
            echo "build_status=partial_failure" >> $GITHUB_OUTPUT
          fi

          # Exibir as √∫ltimas linhas do log para diagn√≥stico imediato.
          echo "--- √öLTIMAS LINHAS DO LOG ---"
          tail -100 build.log || echo "Arquivo de log n√£o encontrado."

      # Passo 6: Coletar e verificar os artefatos gerados
      # Os bootstraps devem estar no diret√≥rio raiz do reposit√≥rio.
      - name: Coletar arquivos bootstrap gerados
        if: always() # Executa mesmo se o build falhar, para inspecionar o que foi produzido.
        id: collect_artifacts
        run: |
          echo "Procurando arquivos bootstrap-*.zip..."
          find . -maxdepth 1 -name "bootstrap-*.zip" -type f | while read file; do
            echo "Encontrado: $file"
            ls -lh "$file"
          done

          COUNT=$(find . -maxdepth 1 -name "bootstrap-*.zip" -type f | wc -l)
          if [ "$COUNT" -gt 0 ]; then
            echo "‚úÖ Encontrados $COUNT arquivo(s) bootstrap."
            echo "bootstrap_count=$COUNT" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Nenhum arquivo bootstrap-*.zip foi gerado."
            echo "bootstrap_count=0" >> $GITHUB_OUTPUT
            # Isso pode ser normal se o build falhou completamente.
          fi

      # Passo 7: Fazer upload dos artefatos (bootstraps e log)
      # Disponibiliza os zips para download e o log completo para depura√ß√£o.
      - name: Fazer upload dos arquivos bootstrap
        if: steps.collect_artifacts.outputs.bootstrap_count > 0
        uses: actions/upload-artifact@v4
        with:
          name: termux-bootstraps-${{ env.TERMUX_APP_PACKAGE }}
          path: |
            ./bootstrap-*.zip
            ./build.log
          retention-days: 30

      # Passo 8: Relat√≥rio final e instru√ß√µes p√≥s-build
      # Resume o resultado e d√° os pr√≥ximos passos claros.
      - name: Relat√≥rio final
        run: |
          echo "========================================="
          echo "         RELAT√ìRIO DO BUILD"
          echo "========================================="
          echo "Pacote configurado: ${{ env.TERMUX_APP_PACKAGE }}"
          echo "Status do build: ${{ steps.run_build.outputs.build_status }}"
          echo "Bootstraps gerados: ${{ steps.collect_artifacts.outputs.bootstrap_count }}"

          if [ "${{ steps.collect_artifacts.outputs.bootstrap_count }}" -gt 0 ]; then
            echo ""
            echo "‚úÖ BOOTSTRAPS GERADOS COM SUCESSO!"
            echo "Pr√≥ximos passos (conforme o tutorial):"
            echo "1. Fa√ßa o download dos arquivos 'bootstrap-*.zip' na aba 'Artifacts' acima."
            echo "2. Extraia o conte√∫do do arquivo correspondente √† arquitetura do seu dispositivo (ex: bootstrap-aarch64.zip)."
            echo "3. Coloque os arquivos extra√≠dos em: /seu/projeto/android/app/src/main/cpp/bootstrap-arm.zip (ou a arquitetura correta)."
            echo "4. No arquivo build.gradle do app Termux, adicione um 'return' no in√≠cio da fun√ß√£o downloadBootstrap() para evitar substitui√ß√£o."
            echo "5. Compile o APK do seu aplicativo Termux personalizado."
          else
            echo ""
            echo "‚ùå Nenhum bootstrap foi gerado."
            echo "Poss√≠veis causas:"
            echo "- O build foi interrompido muito cedo (timeout)."
            echo "- Erros de compila√ß√£o cr√≠ticos nos pacotes."
            echo "- O script build-bootstraps.sh n√£o foi encontrado/executado corretamente."
            echo "Verifique o log completo acima e o arquivo 'build.log' (se dispon√≠vel)."
            echo "Sugest√£o: Tente executar o build para uma √∫nica arquitetura primeiro (ex: aarch64)."
          fi
          echo "========================================="
